import { IObservable, IObserver } from '@lirx/core';
import { HTML_NAMESPACE_URI_CONSTANT } from '../../../../../misc/namespace-uri/html-namespace-uri.constant';
import { createTypedSourcesMap } from '../../../../../misc/typed-sources-map/implementations/create-typed-sources-map';
import { ITypedSourcesMap } from '../../../../../misc/typed-sources-map/implementations/typed-sources-map';
import {
  InferTypedSourcesMapEntriesTupleKeys,
} from '../../../../../misc/typed-sources-map/types/infer-typed-sources-map-entries-tuple-keys.infer';
import {
  InferTypedSourcesMapEntriesTupleValueFromKey,
} from '../../../../../misc/typed-sources-map/types/infer-typed-sources-map-entries-tuple-value-from-key.infer';
import {
  ITypedSourcesMapEntriesTupleToEntriesTuple,
} from '../../../../../misc/typed-sources-map/types/typed-sources-map-entries-tuple-to-entries-tuple.infer';
import { ITypedSourcesMapEntriesTuple } from '../../../../../misc/typed-sources-map/types/typed-sources-map-entries-tuple.type';
import { VirtualReactiveElementNode } from '../element/virtual-reactive-element-node.class';
import { IVirtualCustomElementNodeSlotsMap } from './slots/virtual-custom-element-node-slots-map.type';

/*------------*/

export interface IVirtualCustomElementNodeInterfaces {
  inputs?: ITypedSourcesMapEntriesTuple;
  outputs?: ITypedSourcesMapEntriesTuple;
  io?: ITypedSourcesMapEntriesTuple;
}

export interface IVirtualCustomElementNodeConfig {
  element?: HTMLElement;
  // inputs: ITypedSourcesMapEntriesTuple;
  // outputs: ITypedSourcesMapEntriesTuple;
  // interfaces: ITypedSourcesMapEntriesTuple;
  interfaces?: IVirtualCustomElementNodeInterfaces;
}

export type InferVirtualCustomElementNodeConfigElement<GConfig extends IVirtualCustomElementNodeConfig> =
  GConfig['element'] extends HTMLElement
    ? GConfig['element']
    : HTMLElement;

export type InferVirtualCustomElementNodeConfigInterfaces<GConfig extends IVirtualCustomElementNodeConfig> =
  GConfig['interfaces'] extends IVirtualCustomElementNodeInterfaces
    ? GConfig['interfaces']
    : IVirtualCustomElementNodeInterfaces;

export type InferVirtualCustomElementNodeConfigInterface<// generics
  GConfig extends IVirtualCustomElementNodeConfig,
  GKey extends keyof IVirtualCustomElementNodeInterfaces
  //
  > =
  InferVirtualCustomElementNodeConfigInterfaces<GConfig>[GKey] extends ITypedSourcesMapEntriesTuple
    ? InferVirtualCustomElementNodeConfigInterfaces<GConfig>[GKey]
    : [];

export type InferVirtualCustomElementNodeConfigInputs<GConfig extends IVirtualCustomElementNodeConfig> =
  InferVirtualCustomElementNodeConfigInterface<GConfig, 'inputs'>;

export type InferVirtualCustomElementNodeConfigOutputs<GConfig extends IVirtualCustomElementNodeConfig> =
  InferVirtualCustomElementNodeConfigInterface<GConfig, 'outputs'>;

export type InferVirtualCustomElementNodeConfigIO<GConfig extends IVirtualCustomElementNodeConfig> =
  InferVirtualCustomElementNodeConfigInterface<GConfig, 'io'>;

/*------------*/

export interface InferVirtualCustomElementNodeOptionsInterfaces<GConfig extends IVirtualCustomElementNodeConfig> {
  inputs?: ITypedSourcesMapEntriesTupleToEntriesTuple<InferVirtualCustomElementNodeConfigInputs<GConfig>>;
  outputs?: ITypedSourcesMapEntriesTupleToEntriesTuple<InferVirtualCustomElementNodeConfigOutputs<GConfig>>;
  io?: ITypedSourcesMapEntriesTupleToEntriesTuple<InferVirtualCustomElementNodeConfigIO<GConfig>>;
}

export type InferVirtualCustomElementNodeSetReactiveInputKeys<GConfig extends IVirtualCustomElementNodeConfig> =
  | InferTypedSourcesMapEntriesTupleKeys<InferVirtualCustomElementNodeConfigInputs<GConfig>>
  | InferTypedSourcesMapEntriesTupleKeys<InferVirtualCustomElementNodeConfigIO<GConfig>>
  ;

export type InferVirtualCustomElementNodeSetReactiveInputValueFromKey<// generics
  GConfig extends IVirtualCustomElementNodeConfig,
  GKey extends InferVirtualCustomElementNodeSetReactiveInputKeys<GConfig>
  //
  > =
  GKey extends InferTypedSourcesMapEntriesTupleKeys<InferVirtualCustomElementNodeConfigInputs<GConfig>>
    ? InferTypedSourcesMapEntriesTupleValueFromKey<InferVirtualCustomElementNodeConfigInputs<GConfig>, GKey>
    : InferTypedSourcesMapEntriesTupleValueFromKey<InferVirtualCustomElementNodeConfigIO<GConfig>, GKey>
  ;

// InferTypedSourcesMapEntriesTupleValueFromKey

/*------------*/

export interface IVirtualCustomElementNodeOptions<GConfig extends IVirtualCustomElementNodeConfig> {
  name: string;
  extends?: string;
  slots: IVirtualCustomElementNodeSlotsMap;
  interfaces?: InferVirtualCustomElementNodeOptionsInterfaces<GConfig>;
}

export class VirtualCustomElementNode<GConfig extends IVirtualCustomElementNodeConfig> extends VirtualReactiveElementNode<InferVirtualCustomElementNodeConfigElement<GConfig>> {

  protected readonly _name: string;
  protected readonly _extends: string | undefined;
  protected readonly _slots: IVirtualCustomElementNodeSlotsMap;
  protected readonly _inputs: ITypedSourcesMap<InferVirtualCustomElementNodeConfigInputs<GConfig>>;
  protected readonly _outputs: ITypedSourcesMap<InferVirtualCustomElementNodeConfigOutputs<GConfig>>;
  protected readonly _io: ITypedSourcesMap<InferVirtualCustomElementNodeConfigIO<GConfig>>;

  constructor(
    {
      name,
      extends: _extends,
      slots,
      interfaces = {},
    }: IVirtualCustomElementNodeOptions<GConfig>,
  ) {
    super(
      HTML_NAMESPACE_URI_CONSTANT,
      (_extends === void 0)
        ? name
        : _extends,
    );
    this._name = name;
    this._extends = _extends;
    this._slots = slots;

    type GInputs = ITypedSourcesMapEntriesTupleToEntriesTuple<InferVirtualCustomElementNodeConfigInputs<GConfig>>;
    type GOutputs = ITypedSourcesMapEntriesTupleToEntriesTuple<InferVirtualCustomElementNodeConfigOutputs<GConfig>>;
    type GIO = ITypedSourcesMapEntriesTupleToEntriesTuple<InferVirtualCustomElementNodeConfigIO<GConfig>>;

    const inputs = (interfaces.inputs ?? []) as GInputs;
    const outputs = (interfaces.outputs ?? []) as GOutputs;
    const io = (interfaces.io ?? []) as GIO;

    verifyInterfacesIntegrity(
      inputs as IGenericIO,
      outputs as IGenericIO,
      io as IGenericIO,
    );

    this._inputs = createTypedSourcesMap<InferVirtualCustomElementNodeConfigInputs<GConfig>>(inputs);
    this._outputs = createTypedSourcesMap<InferVirtualCustomElementNodeConfigOutputs<GConfig>>(outputs);
    this._io = createTypedSourcesMap<InferVirtualCustomElementNodeConfigIO<GConfig>>(io);

    if (_extends !== void 0) {
      this.setAttribute('is', name);
    }
  }

  get name(): string {
    return this._name;
  }

  get extends(): string | undefined {
    return this._extends;
  }

  get slots(): IVirtualCustomElementNodeSlotsMap {
    return this._slots;
  }

  get inputs(): ITypedSourcesMap<InferVirtualCustomElementNodeConfigInputs<GConfig>> {
    return this._inputs;
  }

  get outputs(): ITypedSourcesMap<InferVirtualCustomElementNodeConfigOutputs<GConfig>> {
    return this._outputs;
  }

  get io(): ITypedSourcesMap<InferVirtualCustomElementNodeConfigIO<GConfig>> {
    return this._io;
  }

  /* INPUT */

  setReactiveInput<GKey extends InferVirtualCustomElementNodeSetReactiveInputKeys<GConfig>>(
    key: GKey,
    value$: IObservable<InferVirtualCustomElementNodeSetReactiveInputValueFromKey<GConfig, GKey>>,
  ): void {
    type GValue = InferVirtualCustomElementNodeSetReactiveInputValueFromKey<GConfig, GKey>;
    const observer$ = (
      this._inputs.has(key)
        ? this._inputs.$set<GKey>(key)
        : this._io.$set<GKey>(key)
    ) as IObserver<GValue>;
    this.onConnected$(value$)(observer$);
  }

  /* OUTPUT */

  setReactiveOutput<GKey extends InferVirtualCustomElementNodeSetReactiveInputKeys<GConfig>>(
    key: GKey,
    $value: IObserver<InferVirtualCustomElementNodeSetReactiveInputValueFromKey<GConfig, GKey>>,
  ): void {
    type GValue = InferVirtualCustomElementNodeSetReactiveInputValueFromKey<GConfig, GKey>;
    const observable$ = (
      this._inputs.has(key)
        ? this._inputs.get$<GKey>(key)
        : this._io.get$<GKey>(key)
    ) as IObservable<GValue>;
    this.onConnected$(observable$)($value);
  }
}

// export type IGenericGenericVirtualCustomElementNode = VirtualCustomElementNode<HTMLElement, ITypedSourcesMapEntriesTuple>;
export type IGenericGenericVirtualCustomElementNode = VirtualCustomElementNode<IVirtualCustomElementNodeConfig>;

/*-------------------*/

type IGenericIO = readonly [string, ...any[]][];

function verifyInterfacesIntegrity(
  inputs: IGenericIO,
  outputs: IGenericIO,
  io: IGenericIO,
): void {
  const interfacesSet = new Set<string>();

  const addInterface = (
    name: string,
    context: string,
  ): void => {
    if (interfacesSet.has(name)) {
      throw new Error(`Interface '${name}' of '${context}' already exists`);
    } else {
      interfacesSet.add(name);
    }
  };

  inputs.forEach(([name]): void => {
    addInterface(name, 'inputs');
  });

  outputs.forEach(([name]): void => {
    addInterface(name, 'outputs');
  });

  io.forEach(([name]): void => {
    addInterface(name, 'io');
  });
}

/*-----------------*/

interface TestConfig {
  element: HTMLButtonElement;
  interfaces: {
    inputs: [
      ['i-a', boolean],
    ],
    outputs: [
      ['o-a', string],
    ],
    io: [
      ['io-a', number],
    ],
  };
}

const a = new VirtualCustomElementNode<TestConfig>({
  name: 'test',
  slots: new Map(),
  interfaces: {
    inputs: [
      ['i-a', true],
    ],
    outputs: [
      ['o-a'],
    ],
    io: [
      ['io-a', number],
    ],
  },
});
